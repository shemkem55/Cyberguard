from sqlalchemy.orm import Session
from . import models
import datetime
import random

class WebPentestService:
    def create_target(self, db: Session, target_data: dict):
        """
        Phase 1: Register a target. 
        Note: It is created as unauthorized by default.
        """
        target = models.WebTarget(
            domain=target_data["domain"],
            root_url=target_data["root_url"],
            scope_description=target_data.get("scope_description", "Default Scope"),
            authorized=False # Explicitly False until approved
        )
        db.add(target)
        db.commit()
        db.refresh(target)
        return target

    def authorize_target(self, db: Session, target_id: int, auth_ref: str):
        """
        Phase 1: Authorize a target (called after specific admin approval).
        """
        target = db.query(models.WebTarget).filter(models.WebTarget.id == target_id).first()
        if target:
            target.authorized = True
            target.authorization_ref = auth_ref
            db.commit()
            db.refresh(target)
        return target

    def start_recon_session(self, db: Session, target_id: int):
        """
        Phase 2: Start a Safe Reconnaissance Session.
        Checks for authorization first.
        """
        target = db.query(models.WebTarget).filter(models.WebTarget.id == target_id).first()
        if not target:
            return {"status": "error", "message": "Target not found"}
        
        if not target.authorized:
            return {"status": "error", "message": "CRITICAL: Target NOT AUTHORIZED. Recon aborted."}
        
        # Create session
        session = models.PentestSession(
            target_id=target.id,
            status="scanning",
            start_time=datetime.datetime.utcnow(),
            logs=["Session started", "Authorization verified"]
        )
        db.add(session)
        db.commit()
        db.refresh(session)
        
        # In a real app, this would be an async task. For prototype, we simulate synchronous execution.
        self._perform_safe_recon(db, session, target)
        
        return session

    def _perform_safe_recon(self, db: Session, session: models.PentestSession, target: models.WebTarget):
        """
        Simulates Phase 2: Safe Reconnaissance & Mapping.
        """
        # Mock Tech Stack Detection
        tech_stacks = [
            {"Framework": "React", "Server": "Nginx", "Language": "Node.js"},
            {"Framework": "Django", "Server": "Gunicorn", "Language": "Python"},
            {"Framework": "Laravel", "Server": "Apache", "Language": "PHP"}
        ]
        detected_stack = random.choice(tech_stacks)
        target.tech_stack = detected_stack
        
        # Add a log
        current_logs = session.logs or []
        current_logs.append(f"Fingerprinted stack: {detected_stack}")
        
        # Mock Finding Discovery (Phase 3: AI Analysis simulation)
        # In reality, this would crawl, map, and analyze.
        findings = []
        
        # 1. Header Analysis Finding
        findings.append(models.WebFinding(
            session_id=session.id,
            title="Missing Content-Security-Policy",
            url=target.root_url,
            severity="medium",
            description="The Content-Security-Policy (CSP) header is missing, increasing risk of XSS.",
            evidence="Response Headers: Server: Nginx...",
            remediation_advice="Implement a strict CSP to restrict resource loading sources."
        ))
        
        # 2. Information Disclosure
        findings.append(models.WebFinding(
            session_id=session.id,
            title="Server Version Disclosure",
            url=target.root_url,
            severity="low",
            description=f"Server header reveals specific version: {detected_stack['Server']}/1.18.0",
            evidence=f"Server: {detected_stack['Server']}/1.18.0",
            remediation_advice="Configure the server to suppress version information in headers."
        ))

        # 3. Simulate a Phase 4 validation check (Non-destructive)
        if random.random() > 0.5:
             findings.append(models.WebFinding(
                session_id=session.id,
                title="Reflected XSS Potential (Validated)",
                url=f"{target.root_url}/search",
                severity="high",
                description="Input to 'q' parameter is reflected without escaping.",
                evidence="GET /search?q=<script>... -> 200 OK ... <script>...",
                remediation_advice="Ideally, context-aware encoding or sanitization should be applied.",
                confirmed_by_validation=True
            ))

        for f in findings:
            db.add(f)
            
        session.status = "completed"
        session.end_time = datetime.datetime.utcnow()
        session.findings_summary = {"total": len(findings), "critical": 0, "high": 1 if len(findings) > 2 else 0}
        
        db.commit()

web_pentest_service = WebPentestService()
